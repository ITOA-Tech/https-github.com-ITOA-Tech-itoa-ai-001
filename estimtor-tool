import React, { useRef, useState } from "react";

/**
 * InteriorEstimatorApp
 * --------------------
 * Single-file React prototype (Tailwind-ready) that:
 * - accepts inspirational images and room dimensions
 * - extracts a dominant color palette from uploaded images
 * - heuristically classifies style (Modern / Modern-Luxury / Warm-Modern)
 * - produces a line-item breakdown of elements and cost estimates based on room size
 * - outputs a designer-language paragraph describing the client's taste
 *
 * Notes & assumptions (shown inside the app):
 * - Pricing rates are configurable in `baseRates` (INR per sqm or per item)
 * - This is a front-end prototype. For production, extract image features using a Vision API
 *   (AWS Rekognition, Google Vision, or a small fine-tuned classifier) and use a backend
 *   to store pricing database, variant SKUs, and margins.
 *
 * How it delivers customer value:
 * - Fast, repeatable: same rules produce consistent line items and costs
 * - Scalable: replace heuristic classifier with ML model and connect pricing DB
 * - Profitable: shows cost + target margin; easily adjustable markups per SKU
 */

export default function InteriorEstimatorApp() {
  const [images, setImages] = useState([]);
  const [roomWidth, setRoomWidth] = useState(4); // meters
  const [roomLength, setRoomLength] = useState(5); // meters
  const [roomHeight, setRoomHeight] = useState(3);
  const [dominant, setDominant] = useState([]);
  const [style, setStyle] = useState("");
  const [lineItems, setLineItems] = useState([]);
  const [designerParagraph, setDesignerParagraph] = useState("");
  const canvasRef = useRef(null);

  // Base configurable rates (INR)
  const baseRates = {
    flooring_per_sqm: 2500, // marble polished
    wooden_wall_panel_per_sqm: 1800,
    wood_ceiling_per_sqm: 1400,
    led_strip_per_lm: 250,
    glass_balustrade_per_lm: 3500,
    painting_per_sqm: 300,
    installation_pct: 0.12, // 12% installation & contingencies
    margin_pct: 0.18, // target margin 18%
  };

  function handleFiles(e) {
    const files = Array.from(e.target.files);
    const urls = files.map((f) => ({ file: f, url: URL.createObjectURL(f) }));
    setImages(urls);
    setTimeout(() => extractPalette(urls[0]?.url), 200); // quick extract first image
  }

  // Simple dominant color extractor using canvas (client side)
  function extractPalette(imageUrl) {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => {
      const W = 200;
      const H = Math.round((img.height / img.width) * W);
      canvas.width = W;
      canvas.height = H;
      ctx.drawImage(img, 0, 0, W, H);
      const data = ctx.getImageData(0, 0, W, H).data;
      const counts = {};
      for (let i = 0; i < data.length; i += 4 * 8) {
        // sample every 8th pixel for speed
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const key = `${Math.round(r/16)*16},${Math.round(g/16)*16},${Math.round(b/16)*16}`;
        counts[key] = (counts[key] || 0) + 1;
      }
      const sorted = Object.entries(counts).sort((a,b) => b[1]-a[1]).slice(0,5);
      const palette = sorted.map(s => `rgb(${s[0]})`);
      setDominant(palette);
      inferStyleFromPalette(palette);
    };
    img.src = imageUrl;
  }

  // Heuristic style inference
  function inferStyleFromPalette(palette) {
    // rules: warm browns + yellow => Warm-Modern; marble greys + neutral => Modern-Luxury
    const pal = palette.join(" ").toLowerCase();
    let inferred = "Modern";
    if (pal.includes("192") || pal.includes("176") || pal.includes("160")) {
      inferred = "Modern-Luxury";
    }
    if (pal.includes("160") || pal.includes("128")) {
      inferred = "Warm-Modern";
    }
    // if LED warm tones detected
    if (pal.some(p => p.includes("255,192") || p.includes("255,160"))) {
      inferred = inferred + " with Warm Accent Lighting";
    }
    setStyle(inferred);
  }

  function generateEstimate() {
    // Compute area
    const area = Number(roomWidth) * Number(roomLength); // sqm
    const wallArea = (Number(roomWidth) + Number(roomLength)) * 2 * Number(roomHeight);

    // Heuristic elements based on inferred style
    const items = [];

    // Flooring - marble polished
    const flooringCost = area * baseRates.flooring_per_sqm;
    items.push({
      description: `Polished marble flooring - ${area.toFixed(1)} sqm @ ₹${baseRates.flooring_per_sqm}/sqm`,
      qty: area.toFixed(2),
      rate: baseRates.flooring_per_sqm,
      amount: Math.round(flooringCost),
    });

    // Wall wood paneling for 1 feature wall (~ 60% of one wall)
    const featureWallArea = (Number(roomWidth) * Number(roomHeight)) * 0.6;
    const wallPanelAmount = Math.round(featureWallArea * baseRates.wooden_wall_panel_per_sqm);
    items.push({
      description: `Wood wall paneling (feature) - ${featureWallArea.toFixed(1)} sqm @ ₹${baseRates.wooden_wall_panel_per_sqm}/sqm`,
      qty: featureWallArea.toFixed(2),
      rate: baseRates.wooden_wall_panel_per_sqm,
      amount: wallPanelAmount,
    });

    // Ceilings with wood slats (partial) - assume 25% area
    const ceilingWoodArea = area * 0.25;
    const ceilingAmount = Math.round(ceilingWoodArea * baseRates.wood_ceiling_per_sqm);
    items.push({
      description: `Wood slat false ceiling (accent) - ${ceilingWoodArea.toFixed(1)} sqm @ ₹${baseRates.wood_ceiling_per_sqm}/sqm`,
      qty: ceilingWoodArea.toFixed(2),
      rate: baseRates.wood_ceiling_per_sqm,
      amount: ceilingAmount,
    });

    // LED strip lighting (perimeter + stairs/feature) - linear meters heuristic
    const ledLm = (Number(roomWidth) + Number(roomLength)) * 2 * 0.6; // 60% run
    const ledAmount = Math.round(ledLm * baseRates.led_strip_per_lm);
    items.push({
      description: `Integrated LED strip lighting - ${ledLm.toFixed(1)} lm @ ₹${baseRates.led_strip_per_lm}/lm`,
      qty: ledLm.toFixed(2),
      rate: baseRates.led_strip_per_lm,
      amount: ledAmount,
    });

    // Glass balustrade - if staircase inferred (use a default 4 lm)
    const balAmount = Math.round(4 * baseRates.glass_balustrade_per_lm);
    items.push({
      description: `Glass balustrade (smoked) - 4.0 lm @ ₹${baseRates.glass_balustrade_per_lm}/lm`,
      qty: 4.0,
      rate: baseRates.glass_balustrade_per_lm,
      amount: balAmount,
    });

    // Painting for remaining walls
    const paintingAmount = Math.round((wallArea - featureWallArea) * baseRates.painting_per_sqm);
    items.push({
      description: `Emulsion paint for remaining walls - ${(wallArea - featureWallArea).toFixed(1)} sqm @ ₹${baseRates.painting_per_sqm}/sqm`,
      qty: (wallArea - featureWallArea).toFixed(2),
      rate: baseRates.painting_per_sqm,
      amount: paintingAmount,
    });

    // Subtotal
    const subtotal = items.reduce((s, it) => s + it.amount, 0);
    const installation = Math.round(subtotal * baseRates.installation_pct);
    const margin = Math.round((subtotal + installation) * baseRates.margin_pct);
    const total = subtotal + installation + margin;

    // Add summary lines
    items.push({ description: "Sub-total", qty: "", rate: "", amount: Math.round(subtotal) });
    items.push({ description: `Installation & contingencies (${(baseRates.installation_pct*100).toFixed(0)}%)`, qty: "", rate: "", amount: installation });
    items.push({ description: `Target margin (${(baseRates.margin_pct*100).toFixed(0)}%)`, qty: "", rate: "", amount: margin });
    items.push({ description: "Grand Total", qty: "", rate: "", amount: total });

    setLineItems(items);

    // Designer paragraph (concise, designer language)
    const para = `You favour a ${style} approach — characterised by ${dominant.length ? `a neutral-marble ground with ${dominant[0]} accents` : "neutral stone flooring and warm wood"}. The look is restrained and material-led: polished stone underfoot, warm timber anchoring vertical planes, and low-profile glass balustrades to retain spatial porosity. Integrated warm LED cove and stair lighting are used as primary articulators of depth and hierarchy rather than applied ornament. Overall, the preference is modern-minimal with a premium finish palette.`;
    setDesignerParagraph(para);
  }

  function downloadCSV() {
    if (!lineItems.length) return;
    const rows = ["Description,Qty,Rate,Amount", ...lineItems.map(i => `${i.description},${i.qty},${i.rate},${i.amount}`)];
    const blob = new Blob([rows.join("\n")], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "interior-estimate.csv";
    a.click();
  }

  return (
    <div className="p-6 max-w-5xl mx-auto font-sans">
      <h1 className="text-2xl font-semibold mb-4">Interior Estimator Prototype</h1>
      <p className="text-sm text-gray-600 mb-4">Upload inspirational images and provide room size — the app will produce a line-item estimate and a short designer-language summary. (Prototype: replace with backend ML for production.)</p>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <label className="block mb-2">Upload Images</label>
          <input type="file" multiple accept="image/*" onChange={handleFiles} />
          <div className="mt-3 grid grid-cols-3 gap-2">
            {images.map((im, idx) => (
              <img key={idx} src={im.url} className="w-full h-24 object-cover rounded shadow-sm" alt="upload" />
            ))}
          </div>

          <canvas ref={canvasRef} style={{ display: "none" }} />

          <div className="mt-4">
            <label className="block">Room Width (m)</label>
            <input type="number" value={roomWidth} onChange={e=>setRoomWidth(e.target.value)} className="border p-2 rounded w-32" />
            <label className="block mt-2">Room Length (m)</label>
            <input type="number" value={roomLength} onChange={e=>setRoomLength(e.target.value)} className="border p-2 rounded w-32" />
            <label className="block mt-2">Room Height (m)</label>
            <input type="number" value={roomHeight} onChange={e=>setRoomHeight(e.target.value)} className="border p-2 rounded w-32" />
          </div>

          <button className="mt-4 px-4 py-2 bg-sky-600 text-white rounded" onClick={generateEstimate}>Generate Estimate</button>
        </div>

        <div>
          <div className="bg-gray-50 p-4 rounded shadow-sm">
            <h3 className="font-medium">Inferred Style</h3>
            <p className="text-sm text-gray-700">{style || "(upload image to infer)"}</p>
            <h4 className="mt-3 font-medium">Dominant Palette</h4>
            <div className="flex gap-2 mt-2">
              {dominant.length ? dominant.map((c, i) => (
                <div key={i} style={{ background: c }} className="w-12 h-12 rounded border" title={c}></div>
              )) : <p className="text-sm text-gray-500">Palette will appear here</p>}
            </div>

            <h4 className="mt-3 font-medium">Assumptions (editable in code)</h4>
            <ul className="text-xs text-gray-600 list-disc ml-4">
              <li>Flooring assumed polished marble at ₹{baseRates.flooring_per_sqm}/sqm.</li>
              <li>Feature wood wall assumed 60% of one wall.</li>
              <li>Installation & contingencies {Math.round(baseRates.installation_pct*100)}% of subtotal.</li>
              <li>Target mark-up {Math.round(baseRates.margin_pct*100)}% applied to (subtotal+installation).</li>
            </ul>
          </div>
        </div>
      </div>

      <div className="mt-6">
        <h2 className="text-lg font-semibold">Line-item Estimate</h2>
        <div className="overflow-x-auto mt-3 bg-white rounded shadow-sm">
          <table className="w-full text-sm">
            <thead className="bg-gray-100 text-left">
              <tr>
                <th className="p-2">Description</th>
                <th className="p-2">Qty</th>
                <th className="p-2">Rate</th>
                <th className="p-2">Amount (₹)</th>
              </tr>
            </thead>
            <tbody>
              {lineItems.map((it, idx) => (
                <tr key={idx} className={idx%2?"bg-white":"bg-gray-50"}>
                  <td className="p-2 align-top">{it.description}</td>
                  <td className="p-2">{it.qty}</td>
                  <td className="p-2">{it.rate}</td>
                  <td className="p-2 font-medium">{it.amount}</td>
                </tr>
              ))}
              {!lineItems.length && <tr><td className="p-4" colSpan={4}>No estimate generated yet.</td></tr>}
            </tbody>
          </table>
        </div>

        <div className="mt-3 flex gap-2">
          <button className="px-4 py-2 bg-emerald-600 text-white rounded" onClick={downloadCSV}>Download CSV</button>
        </div>

        <h2 className="text-lg font-semibold mt-6">Designer-language Summary</h2>
        <div className="mt-2 p-4 bg-gray-50 rounded">
          <p className="text-sm text-gray-800">{designerParagraph || "(generate estimate to view designer summary)"}</p>
        </div>
      </div>

      <div className="mt-6 p-4 bg-white rounded shadow-sm text-sm">
        <h3 className="font-medium">Roadmap to production (short)</h3>
        <ol className="list-decimal ml-5 mt-2 text-gray-600">
          <li>Replace client-side heuristics with a small Vision/Style classifier (backend) to infer materiality and features reliably.</li>
          <li>Store SKU-level pricing in a central DB; support region-specific pricing and dynamic supplier rates.</li>
          <li>Add procurement & delivery timeline estimates; show margin split (material vs. labour) for profitability analysis.</li>
          <li>Permit customers to choose options (marble grade / laminate / veneer) to convert estimate into an order with configurable upsells.</li>
        </ol>
      </div>

    </div>
  );
}
